package server

import (
	"database/sql"
	"fmt"
	"net/http"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/recover"

	"github.com/zercle/gofiber-skeleton/internal/config"
	"github.com/zercle/gofiber-skeleton/internal/db"
	"github.com/zercle/gofiber-skeleton/internal/logger"
	"github.com/zercle/gofiber-skeleton/internal/middleware"
	"github.com/zercle/gofiber-skeleton/internal/response"
	userHandler "github.com/zercle/gofiber-skeleton/internal/user/handler"
	userRepository "github.com/zercle/gofiber-skeleton/internal/user/repository"
	userUsecase "github.com/zercle/gofiber-skeleton/internal/user/usecase"

	postHandler "github.com/zercle/gofiber-skeleton/internal/post/handler"
	postRepository "github.com/zercle/gofiber-skeleton/internal/post/repository"
	postUsecase "github.com/zercle/gofiber-skeleton/internal/post/usecase"

	// Swagger docs
	_ "github.com/zercle/gofiber-skeleton/docs" // docs is generated by Swag CLI
	fiberswagger "github.com/arsmn/fiber-swagger/v2"
)

// SetupRouter initializes the Fiber app and registers routes
func SetupRouter(sqlDB *sql.DB, cfg *config.Config) *fiber.App {
	app := fiber.New(fiber.Config{
		ErrorHandler: func(c *fiber.Ctx, err error) error {
			// This is a minimal error handler. You might want to expand this.
			code := fiber.StatusInternalServerError
			if e, ok := err.(*fiber.Error); ok {
				code = e.Code
			}
			logger.GetLogger().Error().Err(err).Msg("Unhandled application error")
			return c.Status(code).SendString(err.Error())
		},
	})

	// Global middleware
	app.Use(recover.New())
	app.Use(middleware.RequestID())
	app.Use(middleware.StructuredLogger())

	// Health check routes
	app.Get("/health", healthHandler)
	app.Get("/ready", readinessHandler(sqlDB))

	app.Get("/swagger/*", fiberswagger.HandlerDefault) // default
	app.Get("/swagger/*", fiberswagger.New(fiberswagger.Config{ // custom
		URL:         "http://localhost:8080/swagger/doc.json", //The url pointing to API definition
		DeepLinking: false,
		DocExpansion: "none",
	}))

	// API route group with rate limiting
	api := app.Group("/api", middleware.APIRateLimit())

	// Initialize database queries
	queries := db.New(sqlDB)

	// Initialize user-related components
	userRepo := userRepository.NewPostgresUserRepository(queries)
	authUsecase := userUsecase.NewAuthUsecase(userRepo, cfg.JWTSecret)

	// Initialize post-related components
	postRepo := postRepository.NewPostgresPostRepository(queries)
	postUsecase := postUsecase.NewPostUsecase(postRepo)

	v1 := api.Group("/v1")

	// Auth routes with stricter rate limiting
	authRoutes := v1.Group("/auth", middleware.AuthRateLimit())
	userHandler.RegisterAuthRoutes(authRoutes, authUsecase)

	// Post routes
	postHandler.RegisterPostRoutes(v1, postUsecase, cfg.JWTSecret)

	v1.Get("/users", stubHandler)   // TODO: Implement user routes
	v1.Get("/threads", stubHandler) // TODO: Implement thread routes
	v1.Get("/comments", stubHandler) // TODO: Implement comment routes

	app.Use(func(c *fiber.Ctx) error {
		return c.Status(http.StatusNotFound).SendString("Not Found")
	})

	return app
}

// stubHandler is a placeholder for unimplemented routes
func stubHandler(c *fiber.Ctx) error {
	logger.GetLogger().Warn().Msgf("Route %s not implemented", c.OriginalURL())
	return c.Status(fiber.StatusNotImplemented).SendString(fmt.Sprintf("Route %s Not Implemented", c.OriginalURL()))
}

// healthHandler checks if the service is alive
func healthHandler(c *fiber.Ctx) error {
	return response.Success(c, http.StatusOK, fiber.Map{
		"status": "healthy",
	})
}

// readinessHandler checks if the service is ready to accept requests
func readinessHandler(db *sql.DB) fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Check database connection
		if err := db.Ping(); err != nil {
			logger.GetLogger().Error().Err(err).Msg("Database health check failed")
			return response.Error(c, http.StatusServiceUnavailable, "Service not ready", 5000)
		}

		return response.Success(c, http.StatusOK, fiber.Map{
			"status":   "ready",
			"database": "connected",
		})
	}
}