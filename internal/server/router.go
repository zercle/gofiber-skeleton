package server

import (
	"fmt"
	"net/http"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"gorm.io/gorm"

	"github.com/zercle/gofiber-skeleton/internal/config"
	"github.com/zercle/gofiber-skeleton/internal/db"
	"github.com/zercle/gofiber-skeleton/internal/logger"
	userHandler "github.com/zercle/gofiber-skeleton/internal/user/handler"
	userRepository "github.com/zercle/gofiber-skeleton/internal/user/repository"
	userUsecase "github.com/zercle/gofiber-skeleton/internal/user/usecase"

	postHandler "github.com/zercle/gofiber-skeleton/internal/post/handler"
	postRepository "github.com/zercle/gofiber-skeleton/internal/post/repository"
	postUsecase "github.com/zercle/gofiber-skeleton/internal/post/usecase"

	// Swagger docs
	_ "github.com/zercle/gofiber-skeleton/docs" // docs is generated by Swag CLI
	fiberswagger "github.com/arsmn/fiber-swagger/v2"
)

// SetupRouter initializes the Fiber app and registers routes
func SetupRouter(gormDB *gorm.DB, cfg *config.Config) *fiber.App {
	app := fiber.New(fiber.Config{
		ErrorHandler: func(c *fiber.Ctx, err error) error {
			// This is a minimal error handler. You might want to expand this.
			code := fiber.StatusInternalServerError
			if e, ok := err.(*fiber.Error); ok {
				code = e.Code
			}
			logger.GetLogger().Error().Err(err).Msg("Unhandled application error")
			return c.Status(code).SendString(err.Error())
		},
	})

	app.Use(recover.New())

	// Health check route
	app.Get("/health", func(c *fiber.Ctx) error {
		return c.SendString("OK")
	})

	app.Get("/swagger/*", fiberswagger.HandlerDefault) // default
	app.Get("/swagger/*", fiberswagger.New(fiberswagger.Config{ // custom
		URL:         "http://localhost:8080/swagger/doc.json", //The url pointing to API definition
		DeepLinking: false,
		DocExpansion: "none",
	}))

	// Placeholder route groups
	api := app.Group("/api")

	// Initialize user-related components
	sqlDB, err := gormDB.DB()
	if err != nil {
		logger.GetLogger().Fatal().Err(err).Msg("Failed to get sql.DB from gorm.DB")
	}
	queries := db.New(sqlDB)
	userRepo := userRepository.NewPostgresUserRepository(queries)
	authUsecase := userUsecase.NewAuthUsecase(userRepo, cfg.JWTSecret)

	// Initialize post-related components
	postRepo := postRepository.NewPostgresPostRepository(queries)
	postUsecase := postUsecase.NewPostUsecase(postRepo)

	v1 := api.Group("/v1")

	// Auth routes
	authRoutes := v1.Group("/auth")
	userHandler.RegisterAuthRoutes(authRoutes, authUsecase)

	// Post routes
	postHandler.RegisterPostRoutes(v1, postUsecase, cfg.JWTSecret)

	v1.Get("/users", stubHandler)   // TODO: Implement user routes
	v1.Get("/threads", stubHandler) // TODO: Implement thread routes
	v1.Get("/comments", stubHandler) // TODO: Implement comment routes

	app.Use(func(c *fiber.Ctx) error {
		return c.Status(http.StatusNotFound).SendString("Not Found")
	})

	return app
}

// stubHandler is a placeholder for unimplemented routes
func stubHandler(c *fiber.Ctx) error {
	logger.GetLogger().Warn().Msgf("Route %s not implemented", c.OriginalURL())
	return c.Status(fiber.StatusNotImplemented).SendString(fmt.Sprintf("Route %s Not Implemented", c.OriginalURL()))
}